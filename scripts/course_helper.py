import os
from urllib.parse import quote
import requests

class CourseHelper:
    def __init__(self,
                 access_token: str,
                 canvas_subject_id: str):
        self.access_token = access_token
        self.canvas_subject_id = canvas_subject_id
    
    @property
    def courses(self) -> list[dict]:
        if not hasattr(self, '_courses'):
            self._courses = self.get_subject_info()
        return self._courses
    
    @courses.setter
    def courses(self, value: list[dict]):
        self._courses = value

    @staticmethod
    def from_dict(data: dict) -> 'CourseHelper':
        helper = CourseHelper(
            access_token=data.get('access_token', ''),
            canvas_subject_id=data.get('canvas_subject_id', '')
        )
        helper.courses = data.get('courses', [])
        return helper

    ## --------------------- Course Information Methods --------------------- ##
    def refresh_courses(self) -> list[dict]:
        for course in self.courses:
            download_urls = self.get_video_url(course.get('video_id'))
            course['download_urls'] = download_urls
        return self.courses

    def get_subject_info(self) -> list[dict]:
        """
        Get all courses information of a subject.

        Returns
        -------
        courses : list[dict]
            A list of dictionaries, each containing information about a course.
        """
        url = "https://v.sjtu.edu.cn/jy-application-canvas-sjtu/directOnDemandPlay/findVodVideoList"
        payload = {"canvasCourseId": quote(self.canvas_subject_id)}
        res = requests.post(url, json=payload, headers={'token': self.access_token})
        res.raise_for_status()
        if int(res.json().get('code')) == -1:
            return list()

        data = res.json().get('data')
        
        courses = list()
        for course in data.get('records', []):
            courses.append({
                'id': course.get('courId'),
                'name': course.get('videoName'),
                'dt_start': course.get('courseBeginTime'),
                'dt_end': course.get('courseEndTime'),
                'video_id': course.get('videoId'),
            })

        return courses

    def get_video_url(self, video_id: str) -> dict[int, str]:
        """
        Get the download URLs of a video.

        Parameters
        ----------
        video_id : str
            The ID of the video to get URLs for.

        Returns
        -------
        videos : dict
            A dictionary with keys as channel numbers (0 or 1) and values as
            the corresponding video URLs.
            0: Classroom camera recording
            1: Computer screen recording
        """
        url = "https://v.sjtu.edu.cn/jy-application-canvas-sjtu/directOnDemandPlay/getVodVideoInfos"
        files = {
            "playTypeHls": (None, "true"),
            "isAudit": (None, "true"),
            "id": (None, video_id)
        }

        res = requests.post(url, 
                            files=files, 
                            headers={'token': self.access_token})
        res.raise_for_status()
        data = res.json().get('data')

        videos = dict()
        for video in data.get('videoPlayResponseVoList', []):
            channel = int(video.get('cdviViewNum')) != 0
            videos[int(channel)] = video.get('rtmpUrlHdv')

        return videos
    
    ## ------------------------ AI Abstract Methods ------------------------- ##
    def get_course_abstract(self, course_id: int) -> dict:
        """
        Get the abstract generated by AI for a specific course.

        Parameters
        ----------
        course_id : int
            The ID of the course to get the abstract for.

        Returns
        -------
        dict
            A dictionary containing the abstract, keywords, mindmap nodes,
            and sections of the course.
        """
        url = "https://v.sjtu.edu.cn/jy-application-canvas-sjtu/course/summary/detail"
        payload = {
            'courseId': course_id,
            'platform': 1
        }

        res = requests.post(url, 
                            json=payload, 
                            headers={'token': self.access_token})
        res.raise_for_status()
        data = res.json().get('data')
        
        abstract = data.get('fullOverview', '')
        keywords = data.get('keyPoints', [])
        mindmap_nodes = data.get('mindMapNodes', [])
        sections = list()
        for section in data.get('documentSkims', []):
            sections.append({
                'content': section.get('content', ''),
                'overview': section.get('overview', ''),
                'dt_start': section.get('bg', ''),
                'dt_end': section.get('ed', ''),
            })

        return {
            'abstract': abstract,
            'keywords': keywords,
            'mindmap_nodes': mindmap_nodes,
            'sections': sections
        }
    
    ## ------------------------- Transcript Methods ------------------------- ##
    def get_transcript(self, course_id: int, lang: str = 'zh'):
        url = "https://v.sjtu.edu.cn/jy-application-canvas-sjtu/transfer/translate/detail"
        payload = {
            'courseId': course_id,
            'platform': 1
        }
        res = requests.post(url, 
                            json=payload, 
                            headers={'token': self.access_token})
        res.raise_for_status()
        data = res.json().get('data')
        
        if not data:
            return list()

        transcripts = list()
        for item in data.get('afterAssemblyList', []):
            dt_start = item.get('bg')
            dt_end = item.get('ed')
            if lang == 'zh':
                content = item.get('res')
            else:
                content = item.get(lang)
            transcripts.append({
                'dt_start': dt_start,
                'dt_end': dt_end,
                'content': content
            })
        return transcripts
    
    def save_transcript(self, dirpath: str):
        os.makedirs(dirpath, exist_ok=True)
        for course in self.courses:
            transcripts = self.get_transcript(course['id'], lang='zh')
            if not transcripts:
                continue

            srt_content = parse_srt(transcripts)
            filepath = os.path.join(dirpath, f"{course['name']}_0.srt")
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(srt_content)

## ------------------------ SRT Formatting Functions ------------------------ ##
def format_srt_timestamp(ms: int) -> str:
    """Convert milliseconds to SRT timestamp format (HH:MM:SS,mmm)."""
    hours = ms // 3600000
    ms %= 3600000
    minutes = ms // 60000
    ms %= 60000
    seconds = ms // 1000
    milliseconds = ms % 1000
    return f"{hours:02}:{minutes:02}:{seconds:02},{milliseconds:03}"

def parse_srt(transcripts: list[dict]) -> str:
    """Convert a list of transcript dictionaries to SRT format."""
    srt_content = ""
    for idx, item in enumerate(transcripts, start=1):
        start_time = format_srt_timestamp(item['dt_start'])
        end_time = format_srt_timestamp(item['dt_end'])
        content = item['content'].replace('\n', ' ').strip()
        srt_content += f"{idx}\n{start_time} --> {end_time}\n{content}\n\n"
    return srt_content.strip()


if __name__ == "__main__":
    pass
